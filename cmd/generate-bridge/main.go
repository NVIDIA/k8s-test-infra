// Copyright (c) 2025, NVIDIA CORPORATION.  All rights reserved.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
)

type Function struct {
	Name   string
	Params []Param
}

type Param struct {
	Name string
	Type string
}

func main() {
	input := flag.String("input", "vendor/github.com/NVIDIA/go-nvml/pkg/nvml/nvml.go", "Input file")
	output := flag.String("output", "pkg/gpu/mocknvml/bridge/bridge_generated.go", "Output file")
	flag.Parse()

	functions, err := parseCWrappers(*input)
	if err != nil {
		log.Fatalf("Failed to parse: %v", err)
	}

	log.Printf("Found %d C wrapper functions", len(functions))

	code := generateCompleteBridge(functions)

	formatted, err := format.Source([]byte(code))
	if err != nil {
		log.Printf("Warning: formatting failed: %v", err)
		formatted = []byte(code)
	}

	if err := os.WriteFile(*output, formatted, 0644); err != nil {
		log.Fatalf("Failed to write: %v", err)
	}

	log.Printf("Successfully generated %s", *output)
}

func parseCWrappers(filename string) ([]Function, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, 0)
	if err != nil {
		return nil, err
	}

	var functions []Function

	ast.Inspect(node, func(n ast.Node) bool {
		funcDecl, ok := n.(*ast.FuncDecl)
		if !ok || !strings.HasPrefix(funcDecl.Name.Name, "nvml") {
			return true
		}

		f := Function{Name: funcDecl.Name.Name}

		if funcDecl.Type.Params != nil {
			for _, field := range funcDecl.Type.Params.List {
				paramType := exprToString(field.Type)
				if len(field.Names) > 0 {
					for _, name := range field.Names {
						f.Params = append(f.Params, Param{
							Name: strings.ToLower(name.Name[:1]) + name.Name[1:],
							Type: paramType,
						})
					}
				}
			}
		}

		functions = append(functions, f)
		return true
	})

	return functions, nil
}

func exprToString(expr ast.Expr) string {
	switch e := expr.(type) {
	case *ast.Ident:
		return e.Name
	case *ast.SelectorExpr:
		return exprToString(e.X) + "." + e.Sel.Name
	case *ast.ArrayType:
		return "[]" + exprToString(e.Elt)
	case *ast.StarExpr:
		return "*" + exprToString(e.X)
	default:
		return "interface{}"
	}
}

func generateCompleteBridge(functions []Function) string {
	var buf bytes.Buffer

	// Write complete header with main() and helpers
	buf.WriteString(`// Code generated by cmd/generate-bridge. DO NOT EDIT.
// Copyright (c) 2025, NVIDIA CORPORATION.  All rights reserved.

package main

/*
#include <stdlib.h>
#include <string.h>

typedef int nvmlReturn_t;
typedef void* nvmlDevice_t;

typedef struct nvmlPciInfo_st {
    char busIdLegacy[16];
    unsigned int domain;
    unsigned int bus;
    unsigned int device;
    unsigned int pciDeviceId;
    unsigned int pciSubSystemId;
    char busId[32];
} nvmlPciInfo_t;

typedef struct nvmlMemory_st {
    unsigned long long total;
    unsigned long long free;
    unsigned long long used;
} nvmlMemory_t;

typedef struct nvmlProcessInfo_st {
    unsigned int pid;
    unsigned long long usedGpuMemory;
} nvmlProcessInfo_t;

#define NVML_SUCCESS                    0
#define NVML_ERROR_UNINITIALIZED        1
#define NVML_ERROR_INVALID_ARGUMENT     2
#define NVML_ERROR_NOT_SUPPORTED        3
#define NVML_ERROR_INSUFFICIENT_SIZE    7
#define NVML_ERROR_UNKNOWN              999
*/
import "C"
import (
	"sync"
	"unsafe"

	"github.com/NVIDIA/go-nvml/pkg/nvml"
	"github.com/NVIDIA/k8s-test-infra/pkg/gpu/mocknvml/engine"
)

// errorStringCache caches C strings for nvmlErrorString to avoid memory leaks.
// Real NVML returns static strings, so caching matches expected behavior.
var (
	errorStringCache   = make(map[nvml.Return]*C.char)
	errorStringCacheMu sync.Mutex
)

func main() {
	// Required for buildmode=c-shared
}

func toReturn(ret nvml.Return) C.nvmlReturn_t {
	return C.nvmlReturn_t(ret)
}

func goStringToC(s string, buf *C.char, length C.uint) C.nvmlReturn_t {
	if buf == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	if len(s)+1 > int(length) {
		return C.NVML_ERROR_INSUFFICIENT_SIZE
	}
	cStr := C.CString(s)
	defer C.free(unsafe.Pointer(cStr))
	C.strcpy(buf, cStr)
	return C.NVML_SUCCESS
}

`)

	// Generate all functions
	for _, f := range functions {
		buf.WriteString(generateFunction(f))
		buf.WriteString("\n")
	}

	return buf.String()
}

func generateFunction(f Function) string {
	var buf bytes.Buffer

	// Special case for nvmlErrorString which returns const char*
	if f.Name == "nvmlErrorString" {
		return generateErrorStringFunction()
	}

	fmt.Fprintf(&buf, "//export %s\n", f.Name)
	fmt.Fprintf(&buf, "func %s(", f.Name)
	for i, p := range f.Params {
		if i > 0 {
			buf.WriteString(", ")
		}
		// Special handling for string input parameters - they should be *C.char
		paramType := getCType(p.Type)
		if paramType == "string" && needsCCharParam(f.Name, p.Name) {
			paramType = "*C.char"
		}
		fmt.Fprintf(&buf, "%s %s", p.Name, paramType)
	}
	buf.WriteString(") C.nvmlReturn_t {\n")

	// Check for custom implementations
	if impl := getImplementation(f.Name); impl != "" {
		buf.WriteString(impl)
		buf.WriteString("\n")
	} else {
		buf.WriteString("\treturn C.NVML_ERROR_NOT_SUPPORTED\n")
	}

	buf.WriteString("}\n")
	return buf.String()
}

func generateErrorStringFunction() string {
	return `//export nvmlErrorString
func nvmlErrorString(result C.nvmlReturn_t) *C.char {
	ret := nvml.Return(result)

	errorStringCacheMu.Lock()
	defer errorStringCacheMu.Unlock()

	if cached, ok := errorStringCache[ret]; ok {
		return cached
	}

	str := nvml.ErrorString(ret)
	cStr := C.CString(str)
	errorStringCache[ret] = cStr
	return cStr
}
`
}

// needsCCharParam returns true if the parameter should be *C.char instead of string
func needsCCharParam(funcName, paramName string) bool {
	// Functions that take string inputs from C should use *C.char
	stringInputFuncs := map[string][]string{
		"nvmlDeviceGetHandleByUUID":        {"uuid"},
		"nvmlDeviceGetHandleByPciBusId_v1": {"pciBusId"},
		"nvmlDeviceGetHandleByPciBusId_v2": {"pciBusId"},
		"nvmlDeviceGetHandleBySerial":      {"serial"},
	}

	if params, ok := stringInputFuncs[funcName]; ok {
		for _, p := range params {
			if p == paramName {
				return true
			}
		}
	}
	return false
}

func getImplementation(funcName string) string {
	switch funcName {
	case "nvmlInit", "nvmlInit_v2":
		return `	ret := engine.GetEngine().Init()
	return toReturn(ret)`
	case "nvmlInitWithFlags":
		return `	ret := engine.GetEngine().Init()
	return toReturn(ret)`
	case "nvmlShutdown":
		return `	ret := engine.GetEngine().Shutdown()
	return toReturn(ret)`
	case "nvmlDeviceGetCount", "nvmlDeviceGetCount_v2":
		return `	if deviceCount == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	count, ret := engine.GetEngine().DeviceGetCount()
	if ret == nvml.SUCCESS {
		*(*C.uint)(deviceCount) = C.uint(count)
	}
	return toReturn(ret)`
	case "nvmlDeviceGetHandleByIndex", "nvmlDeviceGetHandleByIndex_v2":
		return `	if nvmlDevice == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	handle, ret := engine.GetEngine().DeviceGetHandleByIndex(int(index))
	if ret == nvml.SUCCESS {
		*(*C.nvmlDevice_t)(nvmlDevice) = *(*C.nvmlDevice_t)(unsafe.Pointer(&handle))
	}
	return toReturn(ret)`
	case "nvmlDeviceGetHandleByUUID":
		return `	if nvmlDevice == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	goUUID := C.GoString(uuid)
	handle, ret := engine.GetEngine().DeviceGetHandleByUUID(goUUID)
	if ret == nvml.SUCCESS {
		*(*C.nvmlDevice_t)(nvmlDevice) = *(*C.nvmlDevice_t)(unsafe.Pointer(&handle))
	}
	return toReturn(ret)`
	case "nvmlDeviceGetHandleByPciBusId_v2", "nvmlDeviceGetHandleByPciBusId_v1":
		return `	if nvmlDevice == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	goPciBusId := C.GoString(pciBusId)
	handle, ret := engine.GetEngine().DeviceGetHandleByPciBusId(goPciBusId)
	if ret == nvml.SUCCESS {
		*(*C.nvmlDevice_t)(nvmlDevice) = *(*C.nvmlDevice_t)(unsafe.Pointer(&handle))
	}
	return toReturn(ret)`
	case "nvmlDeviceGetName":
		return `	dev := engine.GetEngine().LookupDevice(uintptr(nvmlDevice))
	if dev == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	devName, ret := dev.GetName()
	if ret != nvml.SUCCESS {
		return toReturn(ret)
	}
	return goStringToC(devName, (*C.char)(name), length)`
	case "nvmlDeviceGetUUID":
		return `	dev := engine.GetEngine().LookupDevice(uintptr(nvmlDevice))
	if dev == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	devUUID, ret := dev.GetUUID()
	if ret != nvml.SUCCESS {
		return toReturn(ret)
	}
	return goStringToC(devUUID, (*C.char)(uuid), length)`
	case "nvmlDeviceGetPciInfo_v3":
		return `	if pci == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	dev := engine.GetEngine().LookupDevice(uintptr(nvmlDevice))
	if dev == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	info, ret := dev.GetPciInfo()
	if ret != nvml.SUCCESS {
		return toReturn(ret)
	}
	// Copy busId bytes directly
	cPci := (*C.nvmlPciInfo_t)(pci)
	for i := 0; i < 32 && i < len(info.BusId); i++ {
		cPci.busId[i] = C.char(info.BusId[i])
	}
	cPci.domain = C.uint(info.Domain)
	cPci.bus = C.uint(info.Bus)
	cPci.device = C.uint(info.Device)
	cPci.pciDeviceId = C.uint(info.PciDeviceId)
	cPci.pciSubSystemId = C.uint(info.PciSubSystemId)
	return C.NVML_SUCCESS`
	case "nvmlDeviceGetMemoryInfo":
		return `	if memory == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	dev := engine.GetEngine().LookupDevice(uintptr(nvmlDevice))
	if dev == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	info, ret := dev.GetMemoryInfo()
	if ret != nvml.SUCCESS {
		return toReturn(ret)
	}
	cMemory := (*C.nvmlMemory_t)(memory)
	cMemory.total = C.ulonglong(info.Total)
	cMemory.free = C.ulonglong(info.Free)
	cMemory.used = C.ulonglong(info.Used)
	return C.NVML_SUCCESS`
	case "nvmlDeviceGetComputeRunningProcesses_v3":
		return `	if infoCount == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	dev := engine.GetEngine().LookupDevice(uintptr(nvmlDevice))
	if dev == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	processes, ret := dev.GetComputeRunningProcesses()
	if ret != nvml.SUCCESS {
		return toReturn(ret)
	}
	*(*uint32)(infoCount) = uint32(len(processes))
	return toReturn(nvml.SUCCESS)`
	case "nvmlDeviceGetGraphicsRunningProcesses_v3":
		return `	if infoCount == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	dev := engine.GetEngine().LookupDevice(uintptr(nvmlDevice))
	if dev == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	processes, ret := dev.GetGraphicsRunningProcesses()
	if ret != nvml.SUCCESS {
		return toReturn(ret)
	}
	*(*uint32)(infoCount) = uint32(len(processes))
	return toReturn(nvml.SUCCESS)`
	case "nvmlSystemGetDriverVersion":
		return `	if version == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	driverVersion, ret := engine.GetEngine().SystemGetDriverVersion()
	if ret != nvml.SUCCESS {
		return toReturn(ret)
	}
	return goStringToC(driverVersion, (*C.char)(version), length)`
	case "nvmlDeviceGetMinorNumber":
		return `	if minorNumber == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	dev := engine.GetEngine().LookupDevice(uintptr(nvmlDevice))
	if dev == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	minor, ret := dev.GetMinorNumber()
	if ret == nvml.SUCCESS {
		*(*C.uint)(minorNumber) = C.uint(minor)
	}
	return toReturn(ret)`
	case "nvmlDeviceGetIndex":
		return `	if index == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	dev := engine.GetEngine().LookupDevice(uintptr(nvmlDevice))
	if dev == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	idx, ret := dev.GetIndex()
	if ret == nvml.SUCCESS {
		*(*C.uint)(index) = C.uint(idx)
	}
	return toReturn(ret)`
	case "nvmlDeviceGetCudaComputeCapability":
		return `	if major == nil || minor == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	dev := engine.GetEngine().LookupDevice(uintptr(nvmlDevice))
	if dev == nil {
		return C.NVML_ERROR_INVALID_ARGUMENT
	}
	maj, min, ret := dev.GetCudaComputeCapability()
	if ret == nvml.SUCCESS {
		*(*C.int)(major) = C.int(maj)
		*(*C.int)(minor) = C.int(min)
	}
	return toReturn(ret)`
	default:
		return ""
	}
}

func getCType(goType string) string {
	switch {
	case goType == "*byte":
		return "unsafe.Pointer"
	case goType == "string":
		return "string"
	case goType == "uint32":
		return "C.uint"
	case goType == "*uint32":
		return "unsafe.Pointer"
	case goType == "int32":
		return "C.int"
	case goType == "*int32":
		return "unsafe.Pointer"
	case goType == "uint64":
		return "C.ulonglong"
	case goType == "*uint64":
		return "unsafe.Pointer"
	case strings.Contains(goType, "Device") || strings.Contains(goType, "device"):
		return "unsafe.Pointer"
	default:
		return "unsafe.Pointer"
	}
}
