/* Code generated by cmd/cgo; DO NOT EDIT. */

/* package github.com/NVIDIA/k8s-test-infra/pkg/gpu/mocknvml/bridge */


#line 1 "cgo-builtin-export-prolog"

#include <stddef.h>

#ifndef GO_CGO_EXPORT_PROLOGUE_H
#define GO_CGO_EXPORT_PROLOGUE_H

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef struct { const char *p; ptrdiff_t n; } _GoString_;
extern size_t _GoStringLen(_GoString_ s);
extern const char *_GoStringPtr(_GoString_ s);
#endif

#endif

/* Start of preamble from import "C" comments.  */


#line 16 "bridge.go"

#include <stdlib.h>
#include <string.h>

typedef int nvmlReturn_t;
typedef void* nvmlDevice_t;

#define NVML_SUCCESS                    0
#define NVML_ERROR_UNINITIALIZED        1
#define NVML_ERROR_INVALID_ARGUMENT     2
#define NVML_ERROR_NOT_SUPPORTED        3
#define NVML_ERROR_INSUFFICIENT_SIZE    7
#define NVML_ERROR_UNKNOWN              999

#line 1 "cgo-generated-wrapper"

#line 16 "device.go"

#include <stdlib.h>
#include <string.h>

typedef int nvmlReturn_t;
typedef void* nvmlDevice_t;

#define NVML_SUCCESS                    0
#define NVML_ERROR_INVALID_ARGUMENT     2
#define NVML_ERROR_INSUFFICIENT_SIZE    7

#line 1 "cgo-generated-wrapper"

#line 16 "events.go"

#include <stdlib.h>

typedef int nvmlReturn_t;
typedef void* nvmlDevice_t;
typedef void* nvmlEventSet_t;
typedef unsigned long long ulonglong;

#define NVML_SUCCESS                0
#define NVML_ERROR_NOT_SUPPORTED    3

#line 1 "cgo-generated-wrapper"

#line 16 "memory.go"

#include <stdlib.h>

typedef int nvmlReturn_t;
typedef void* nvmlDevice_t;

#define NVML_SUCCESS                0
#define NVML_ERROR_INVALID_ARGUMENT 2

typedef struct {
    unsigned long long total;
    unsigned long long free;
    unsigned long long used;
} nvmlMemory_t;

typedef struct {
    unsigned long long total;
    unsigned long long reserved;
    unsigned long long free;
    unsigned long long used;
} nvmlMemory_v2_t;

typedef struct {
    unsigned long long bar1Total;
    unsigned long long bar1Free;
    unsigned long long bar1Used;
} nvmlBAR1Memory_t;

#line 1 "cgo-generated-wrapper"

#line 16 "mig.go"

#include <stdlib.h>

typedef int nvmlReturn_t;
typedef void* nvmlDevice_t;

#define NVML_SUCCESS                0
#define NVML_ERROR_NOT_SUPPORTED 3
#define NVML_ERROR_INVALID_ARGUMENT 2

#line 1 "cgo-generated-wrapper"

#line 16 "pci.go"

#include <stdlib.h>
#include <string.h>

typedef int nvmlReturn_t;
typedef void* nvmlDevice_t;

#define NVML_SUCCESS                0
#define NVML_ERROR_INVALID_ARGUMENT 2

#define NVML_DEVICE_PCI_BUS_ID_BUFFER_SIZE 32
#define NVML_DEVICE_PCI_BUS_ID_BUFFER_V2_SIZE 16

typedef struct {
    char busIdLegacy[NVML_DEVICE_PCI_BUS_ID_BUFFER_V2_SIZE];
    unsigned int domain;
    unsigned int bus;
    unsigned int device;
    unsigned int pciDeviceId;
    unsigned int pciSubSystemId;
    char busId[NVML_DEVICE_PCI_BUS_ID_BUFFER_SIZE];
} nvmlPciInfo_t;

#line 1 "cgo-generated-wrapper"

#line 16 "process.go"

#include <stdlib.h>

typedef int nvmlReturn_t;
typedef void* nvmlDevice_t;

#define NVML_SUCCESS                0
#define NVML_ERROR_INVALID_ARGUMENT 2
#define NVML_ERROR_INSUFFICIENT_SIZE 7

typedef struct {
    unsigned int pid;
    unsigned long long usedGpuMemory;
    unsigned int gpuInstanceId;
    unsigned int computeInstanceId;
} nvmlProcessInfo_t;

#line 1 "cgo-generated-wrapper"

#line 16 "util.go"

#include <stdlib.h>

typedef int nvmlReturn_t;
typedef void* nvmlDevice_t;

#define NVML_SUCCESS                0
#define NVML_ERROR_INVALID_ARGUMENT 2
#define NVML_ERROR_NOT_SUPPORTED    3

typedef enum {
    NVML_TEMPERATURE_GPU = 0
} nvmlTemperatureSensors_t;

typedef enum {
    NVML_CLOCK_GRAPHICS = 0,
    NVML_CLOCK_SM       = 1,
    NVML_CLOCK_MEM      = 2
} nvmlClockType_t;

#line 1 "cgo-generated-wrapper"


/* End of preamble from import "C" comments.  */


/* Start of boilerplate cgo prologue.  */
#line 1 "cgo-gcc-export-header-prolog"

#ifndef GO_CGO_PROLOGUE_H
#define GO_CGO_PROLOGUE_H

typedef signed char GoInt8;
typedef unsigned char GoUint8;
typedef short GoInt16;
typedef unsigned short GoUint16;
typedef int GoInt32;
typedef unsigned int GoUint32;
typedef long long GoInt64;
typedef unsigned long long GoUint64;
typedef GoInt64 GoInt;
typedef GoUint64 GoUint;
typedef size_t GoUintptr;
typedef float GoFloat32;
typedef double GoFloat64;
#ifdef _MSC_VER
#if !defined(__cplusplus) || _MSVC_LANG <= 201402L
#include <complex.h>
typedef _Fcomplex GoComplex64;
typedef _Dcomplex GoComplex128;
#else
#include <complex>
typedef std::complex<float> GoComplex64;
typedef std::complex<double> GoComplex128;
#endif
#else
typedef float _Complex GoComplex64;
typedef double _Complex GoComplex128;
#endif

/*
  static assertion to make sure the file is being used on architecture
  at least with matching size of GoInt.
*/
typedef char _check_for_64_bit_pointer_matching_GoInt[sizeof(void*)==64/8 ? 1:-1];

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef _GoString_ GoString;
#endif
typedef void *GoMap;
typedef void *GoChan;
typedef struct { void *t; void *v; } GoInterface;
typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;

#endif

/* End of boilerplate cgo prologue.  */

#ifdef __cplusplus
extern "C" {
#endif

extern nvmlReturn_t nvmlInit_v2(void);
extern nvmlReturn_t nvmlInit(void);
extern nvmlReturn_t nvmlShutdown(void);
extern nvmlReturn_t nvmlDeviceGetCount_v2(unsigned int* deviceCount);
extern nvmlReturn_t nvmlDeviceGetCount(unsigned int* deviceCount);
extern nvmlReturn_t nvmlDeviceGetHandleByIndex_v2(unsigned int index, nvmlDevice_t* device);
extern nvmlReturn_t nvmlDeviceGetHandleByIndex(unsigned int index, nvmlDevice_t* device);
extern nvmlReturn_t nvmlDeviceGetHandleByUUID(char* uuid, nvmlDevice_t* device);
extern nvmlReturn_t nvmlDeviceGetHandleByPciBusId_v2(char* pciBusId, nvmlDevice_t* device);
extern nvmlReturn_t nvmlDeviceGetHandleByPciBusId(char* pciBusId, nvmlDevice_t* device);
extern nvmlReturn_t nvmlSystemGetDriverVersion(char* version, unsigned int length);
extern nvmlReturn_t nvmlSystemGetNVMLVersion(char* version, unsigned int length);
extern nvmlReturn_t nvmlSystemGetCudaDriverVersion(int* cudaDriverVersion);
extern nvmlReturn_t nvmlSystemGetCudaDriverVersion_v2(int* cudaDriverVersion);
extern char* nvmlErrorString(nvmlReturn_t result);
extern nvmlReturn_t nvmlDeviceGetName(nvmlDevice_t device, char* name, unsigned int length);
extern nvmlReturn_t nvmlDeviceGetUUID(nvmlDevice_t device, char* uuid, unsigned int length);
extern nvmlReturn_t nvmlDeviceGetMinorNumber(nvmlDevice_t device, unsigned int* minorNumber);
extern nvmlReturn_t nvmlDeviceGetIndex(nvmlDevice_t device, unsigned int* index);
extern nvmlReturn_t nvmlEventSetCreate(nvmlEventSet_t* set);
extern nvmlReturn_t nvmlDeviceRegisterEvents(nvmlDevice_t device, unsigned long long eventTypes, nvmlEventSet_t set);
extern nvmlReturn_t nvmlEventSetWait(nvmlEventSet_t set, void* data, unsigned int timeoutms);
extern nvmlReturn_t nvmlEventSetWait_v2(nvmlEventSet_t set, void* data, unsigned int timeoutms);
extern nvmlReturn_t nvmlEventSetFree(nvmlEventSet_t set);
extern nvmlReturn_t nvmlDeviceGetMemoryInfo(nvmlDevice_t device, nvmlMemory_t* memory);
extern nvmlReturn_t nvmlDeviceGetMemoryInfo_v2(nvmlDevice_t device, nvmlMemory_v2_t* memory);
extern nvmlReturn_t nvmlDeviceGetBAR1MemoryInfo(nvmlDevice_t device, nvmlBAR1Memory_t* bar1Memory);
extern nvmlReturn_t nvmlDeviceGetMigMode(nvmlDevice_t device, unsigned int* currentMode, unsigned int* pendingMode);
extern nvmlReturn_t nvmlDeviceGetMaxMigDeviceCount(nvmlDevice_t device, unsigned int* count);
extern nvmlReturn_t nvmlDeviceSetMigMode(nvmlDevice_t device, unsigned int mode, unsigned int* activationStatus);
extern nvmlReturn_t nvmlDeviceGetGpuInstanceProfileInfo(nvmlDevice_t device, unsigned int profile, void* info);
extern nvmlReturn_t nvmlDeviceGetGpuInstances(nvmlDevice_t device, unsigned int profileId, void* instances, unsigned int* count);
extern nvmlReturn_t nvmlDeviceGetPciInfo(nvmlDevice_t device, nvmlPciInfo_t* pci);
extern nvmlReturn_t nvmlDeviceGetPciInfo_v2(nvmlDevice_t device, nvmlPciInfo_t* pci);
extern nvmlReturn_t nvmlDeviceGetPciInfo_v3(nvmlDevice_t device, nvmlPciInfo_t* pci);
extern nvmlReturn_t nvmlDeviceGetCudaComputeCapability(nvmlDevice_t device, int* major, int* minor);
extern nvmlReturn_t nvmlDeviceGetBrand(nvmlDevice_t device, int* brandType);
extern nvmlReturn_t nvmlDeviceGetArchitecture(nvmlDevice_t device, int* arch);
extern nvmlReturn_t nvmlDeviceGetComputeRunningProcesses(nvmlDevice_t device, unsigned int* infoCount, nvmlProcessInfo_t* infos);
extern nvmlReturn_t nvmlDeviceGetComputeRunningProcesses_v2(nvmlDevice_t device, unsigned int* infoCount, nvmlProcessInfo_t* infos);
extern nvmlReturn_t nvmlDeviceGetComputeRunningProcesses_v3(nvmlDevice_t device, unsigned int* infoCount, nvmlProcessInfo_t* infos);
extern nvmlReturn_t nvmlDeviceGetGraphicsRunningProcesses(nvmlDevice_t device, unsigned int* infoCount, nvmlProcessInfo_t* infos);
extern nvmlReturn_t nvmlDeviceGetGraphicsRunningProcesses_v2(nvmlDevice_t device, unsigned int* infoCount, nvmlProcessInfo_t* infos);
extern nvmlReturn_t nvmlDeviceGetGraphicsRunningProcesses_v3(nvmlDevice_t device, unsigned int* infoCount, nvmlProcessInfo_t* infos);
extern nvmlReturn_t nvmlDeviceGetTemperature(nvmlDevice_t device, nvmlTemperatureSensors_t sensorType, unsigned int* temp);
extern nvmlReturn_t nvmlDeviceGetPowerUsage(nvmlDevice_t device, unsigned int* power);
extern nvmlReturn_t nvmlDeviceGetPowerManagementLimit(nvmlDevice_t device, unsigned int* limit);
extern nvmlReturn_t nvmlDeviceGetClock(nvmlDevice_t device, nvmlClockType_t clockType, int clockId, unsigned int* clock);
extern nvmlReturn_t nvmlDeviceGetMaxClockInfo(nvmlDevice_t device, nvmlClockType_t clockType, unsigned int* clock);
extern nvmlReturn_t nvmlDeviceGetFanSpeed(nvmlDevice_t device, unsigned int* speed);
extern nvmlReturn_t nvmlDeviceGetPerformanceState(nvmlDevice_t device, int* pState);

#ifdef __cplusplus
}
#endif
